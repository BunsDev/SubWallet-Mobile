diff --git a/node_modules/@noble/secp256k1/lib/index.js b/node_modules/@noble/secp256k1/lib/index.js
index 38fbf76..d9b215d 100644
--- a/node_modules/@noble/secp256k1/lib/index.js
+++ b/node_modules/@noble/secp256k1/lib/index.js
@@ -8,11 +8,11 @@ const _1n = BigInt(1);
 const _2n = BigInt(2);
 const _3n = BigInt(3);
 const _8n = BigInt(8);
-const POW_2_256 = _2n ** BigInt(256);
+const POW_2_256 = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639936');
 const CURVE = {
     a: _0n,
     b: BigInt(7),
-    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
+    P: POW_2_256 - BigInt('4294967296') - BigInt(977),
     n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),
     h: _1n,
     Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
@@ -51,8 +51,8 @@ class JacobianPoint {
             throw new TypeError('JacobianPoint expected');
         const { x: X1, y: Y1, z: Z1 } = this;
         const { x: X2, y: Y2, z: Z2 } = other;
-        const Z1Z1 = mod(Z1 ** _2n);
-        const Z2Z2 = mod(Z2 ** _2n);
+        const Z1Z1 = mod(Z1 * Z1);
+        const Z2Z2 = mod(Z2 * Z2);
         const U1 = mod(X1 * Z2Z2);
         const U2 = mod(X2 * Z1Z1);
         const S1 = mod(mod(Y1 * Z2) * Z2Z2);
@@ -64,12 +64,12 @@ class JacobianPoint {
     }
     double() {
         const { x: X1, y: Y1, z: Z1 } = this;
-        const A = mod(X1 ** _2n);
-        const B = mod(Y1 ** _2n);
-        const C = mod(B ** _2n);
-        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
+        const A = mod(X1 * X1);
+        const B = mod(Y1 * Y1);
+        const C = mod(B * B);
+        const D = mod(_2n * (mod((X1 + B) * (X1 + B)) - A - C));
         const E = mod(_3n * A);
-        const F = mod(E ** _2n);
+        const F = mod(E * E);
         const X3 = mod(F - _2n * D);
         const Y3 = mod(E * (D - X3) - _8n * C);
         const Z3 = mod(_2n * Y1 * Z1);
@@ -84,8 +84,8 @@ class JacobianPoint {
             return this;
         if (X1 === _0n || Y1 === _0n)
             return other;
-        const Z1Z1 = mod(Z1 ** _2n);
-        const Z2Z2 = mod(Z2 ** _2n);
+        const Z1Z1 = mod(Z1 * Z1);
+        const Z2Z2 = mod(Z2 * Z2);
         const U1 = mod(X1 * Z2Z2);
         const U2 = mod(X2 * Z1Z1);
         const S1 = mod(mod(Y1 * Z2) * Z2Z2);
@@ -100,10 +100,10 @@ class JacobianPoint {
                 return JacobianPoint.ZERO;
             }
         }
-        const HH = mod(H ** _2n);
+        const HH = mod(H * H);
         const HHH = mod(H * HH);
         const V = mod(U1 * HH);
-        const X3 = mod(r ** _2n - HHH - _2n * V);
+        const X3 = mod(r * r - HHH - _2n * V);
         const Y3 = mod(r * (V - X3) - S1 * HHH);
         const Z3 = mod(Z1 * Z2 * H);
         return new JacobianPoint(X3, Y3, Z3);
@@ -626,7 +626,7 @@ function invertBatch(nums, p = CURVE.P) {
     return scratch;
 }
 const divNearest = (a, b) => (a + b / _2n) / b;
-const POW_2_128 = _2n ** BigInt(128);
+const POW_2_128 = BigInt('340282366920938463463374607431768211456');
 function splitScalarEndo(k) {
     const { n } = CURVE;
     const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
